import java.util.InputMismatchException;import java.util.Random;import java.util.Scanner;import java.util.stream.IntStream;/** * A class Radix Sort tester * * @author Jamie Hernandez * @version 3/10/2020 */public class SortChain<T extends Comparable<? super T>>{    private ChainOfNodes<String> data;    private final int ASCII_Z = 90;    private final int ASCII_A = 65;    public SortChain(int listSize, int maxLength)    {        // TODO Project 3-1 - needs debugging        this.data = new ChainOfNodes<>();        Random r = new Random(101);        StringBuffer str;        for (int j = 0; j < listSize; j++){            str = new StringBuffer(maxLength);            for (int i = 0; i < (r.nextInt(maxLength) + 1); i++){                int  randCh = (r.nextInt(ASCII_Z - ASCII_A) + ASCII_A);                char ch = (char) randCh;                str.append(ch);            }            this.data.add(str.toString());        }    }    public void sortChainOfNodes()    {        System.out.println("The original list is: ");        this.data.display();        stringRadixSort();        System.out.println("The original list sorted with RadixSort: ");        this.data.display();    }    /**     * RADIX SORT     * sorts String objects in this.data chain of nodes     */    public void stringRadixSort()    {        // TODO Project 3-2 - in progress        final int NUMBER_OF_UPPER_CASE_LETTERS = 26;        ChainOfNodes<String> buckets = new ChainOfNodes<>();        Node currentNode = this.data.firstNode;        int longest = 0;        // do nothing if no more than one node        if (currentNode != null && currentNode.next == null){            System.out.println("do nothing");        }else {            //create buckets, fill with null            for (int i = 0; i < NUMBER_OF_UPPER_CASE_LETTERS + 1; i++){//                buckets.clear();                buckets.add(null);            }            //traverse the chain to find the longest string            longest = currentNode.data.toString().length();            while (currentNode != null){                if (currentNode.data.toString().length() > longest){                    longest = currentNode.data.toString().length();                }                currentNode = currentNode.next;            }        }        int max = longest; // THIS IS A STUB        System.out.println("\u001B[35m\u001B[1m  The longest string has " + max + " characters so the number of needed passes is " + max + "\u001B[0m\n");        // start sorting        // for each pass:            // distribute nodes to appropriate buckets            // clear the original chain and add the nodes back in "buckets" order            // clear buckets        for (int i = 0; i < longest; i++){                    }    }    public static void main(String args[])    {        int listSize = 0;        int maxLength = 0;        boolean invalidInput;        // get input        do        {            try            {                invalidInput = false;                Scanner keyboard = new Scanner(System.in);                System.out.println("How many nodes?" + "\n It should be an integer value greater than or equal to 1.");                listSize = keyboard.nextInt();                System.out.println("How many characters in the longest string?" + "\n It should be an integer value greater than or equal to 1.");                maxLength = keyboard.nextInt();            } catch (InputMismatchException ime)            {                System.out.println("Could not convert input to an integer");                invalidInput = true;            } catch (Exception e)            {                System.out.println("There was an error with System.in");                System.out.println(e.getMessage());                invalidInput = true;            }        } while (invalidInput);        SortChain tester = new SortChain(listSize, maxLength);        tester.sortChainOfNodes();    }    private class ChainOfNodes<T extends Comparable<? super T>>    {        private Node<T> firstNode;       // reference to first node        public ChainOfNodes()        {            this.firstNode = null;        } // end default constructor        /**         * Adds a new entry to the end of the chain.         *         * @param newEntry the object to be added as a new entry         * @return true         */        public boolean add(T newEntry) // OutOfMemoryError possible        {            // add to the end of the chain:            Node<T> newNode = new Node<>(newEntry);            if (this.firstNode == null)                this.firstNode = newNode;            else            {                Node<T> currentNode = this.firstNode;                while (currentNode.next != null)                    currentNode = currentNode.next;                currentNode.next = newNode;            }            return true;        } // end add        /**         * Removes all entries from this bag.         */        public void clear()        {            this.firstNode = null;        } // end clear        /**         * Displays all entries in this chain of nodes.         */        public void display()        {            Node<T> currentNode = this.firstNode;            while (currentNode != null)            {                System.out.print(currentNode.data + " ");                currentNode = currentNode.next;            }            System.out.println();        }    } // end ChainOfNodes    private class Node<S>    {        private S data; // entry in bag        private Node<S> next; // link to next node        private Node(S dataPortion)        {            this(dataPortion, null);        } // end constructor        private Node(S dataPortion, Node<S> nextNode)        {            this.data = dataPortion;            this.next = nextNode;        }    } // end Node} // end RadixSort